{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nbrain_inertial = Inertial()\nLeftBase = Motor(Ports.PORT2, False)\nRightBase = Motor(Ports.PORT10, True)\nSlapshot = Motor(Ports.PORT1, False)\nBluetower = Motor(Ports.PORT3, False)\nPurpletower = Motor(Ports.PORT12, False)\nbucket = Motor(Ports.PORT7, False)\ngyro_5 = Gyro(Ports.PORT5)\ncontroller = Controller()\ntouchled_4 = Touchled(Ports.PORT4)\nbumper_6 = Bumper(Ports.PORT6)\n#endregion VEXcode Generated Robot Configuration\n\n# ------------------------------------------\n# \n# \tProject:      VEXcode Project\n# \tAuthor:       VEX\n# \tCreated:\n# \tDescription:  VEXcode IQ Python Project\n# \n# ------------------------------------------\nfrom vex import *\n#from multiprocessing import Process\n# Begin project code\ndef set_robot_motors():\n    LeftBase.set_velocity(70,PERCENT)                  # Setting driving speed to 100\n    RightBase.set_velocity(70,PERCENT)\n    RightBase.set_stopping(BRAKE)\n    LeftBase.set_stopping(BRAKE)\n    Slapshot.set_max_torque(100,PERCENT)                #set max torque of slapshot to 100\n    Slapshot.set_velocity(100,PERCENT)                  #set the velocity of Slapshot to 100\n    bucket.set_velocity(100,PERCENT)                    #set velocity of bucket to 100\n    bucket.set_max_torque(75, PERCENT)\n    Bluetower.set_velocity(100,PERCENT)                 #set blue tower speed to 100\n    Purpletower.set_velocity(100,PERCENT)               #set purple tower velocity to 100\n    Bluetower.set_position(0, DEGREES)                  #set position of Blue\n    Bluetower.set_stopping(HOLD)                        #set stopping of Blue\n    bucket.set_stopping(HOLD)                           #set stopping of bucket\n\n#set_robot_motors()\ndef driveStraight_dividedistanceby2(driveStraight_distance_heading_velocity_kp__distance, driveStraight_distance_heading_velocity_kp__heading, driveStraight_distance_heading_velocity_kp__velocity, driveStraight_distance_heading_velocity_kp__kp):\n    global myVariable, error, output\n    #drives very Straight and works very well\n    LeftBase.set_position(0, DEGREES)\n    RightBase.set_position(0, DEGREES)\n    if driveStraight_distance_heading_velocity_kp__velocity > 0:\n        while LeftBase.position(DEGREES) < driveStraight_distance_heading_velocity_kp__distance:\n            error = driveStraight_distance_heading_velocity_kp__heading - brain_inertial.rotation()\n            output = error * driveStraight_distance_heading_velocity_kp__kp\n            LeftBase.set_velocity((driveStraight_distance_heading_velocity_kp__velocity - output), PERCENT)\n            RightBase.set_velocity((driveStraight_distance_heading_velocity_kp__velocity + output), PERCENT)\n            LeftBase.spin(FORWARD)\n            RightBase.spin(FORWARD)\n            wait(20, MSEC)\n    else:\n        while LeftBase.position(DEGREES) > driveStraight_distance_heading_velocity_kp__distance:\n            error = driveStraight_distance_heading_velocity_kp__heading - brain_inertial.rotation()\n            output = error * driveStraight_distance_heading_velocity_kp__kp\n            LeftBase.set_velocity((driveStraight_distance_heading_velocity_kp__velocity - output), PERCENT)\n            RightBase.set_velocity((driveStraight_distance_heading_velocity_kp__velocity + output), PERCENT)\n            LeftBase.spin(FORWARD)\n            RightBase.spin(FORWARD)\n            wait(20, MSEC)\n    LeftBase.stop()\n    RightBase.stop()\ndef driveReverse_dividedistanceby2(driveStraight_distance_heading_velocity_kp__distance, driveStraight_distance_heading_velocity_kp__heading, driveStraight_distance_heading_velocity_kp__velocity, driveStraight_distance_heading_velocity_kp__kp):\n    global myVariable, error, output\n    #drives very Straight and works very well\n    LeftBase.set_position(0, DEGREES)\n    RightBase.set_position(0, DEGREES)\n    if driveStraight_distance_heading_velocity_kp__velocity > 0:\n        while LeftBase.position(DEGREES) < driveStraight_distance_heading_velocity_kp__distance:\n            error = driveStraight_distance_heading_velocity_kp__heading - brain_inertial.rotation()\n            output = error * driveStraight_distance_heading_velocity_kp__kp\n            LeftBase.set_velocity(-(driveStraight_distance_heading_velocity_kp__velocity + output), PERCENT)\n            RightBase.set_velocity(-(driveStraight_distance_heading_velocity_kp__velocity - output), PERCENT)\n            LeftBase.spin(FORWARD)\n            RightBase.spin(FORWARD)\n            wait(20, MSEC)\n    else:\n        while LeftBase.position(DEGREES) > driveStraight_distance_heading_velocity_kp__distance:\n            error = driveStraight_distance_heading_velocity_kp__heading - brain_inertial.rotation()\n            output = error * driveStraight_distance_heading_velocity_kp__kp\n            LeftBase.set_velocity(-(driveStraight_distance_heading_velocity_kp__velocity + output), PERCENT)\n            RightBase.set_velocity(-(driveStraight_distance_heading_velocity_kp__velocity - output), PERCENT)\n            LeftBase.spin(FORWARD)\n            RightBase.spin(FORWARD)\n            wait(20, MSEC)\n    LeftBase.stop()\n    RightBase.stop()\n\ndef turn_heading_velocity_momentum(turn_heading_velocity_momentum__heading, turn_heading_velocity_momentum__velocity, turn_heading_velocity_momentum__momentum):\n    if turn_heading_velocity_momentum__heading > brain_inertial.rotation():\n        # left\n        while turn_heading_velocity_momentum__heading - turn_heading_velocity_momentum__momentum > gyro_5.rotation():\n            LeftBase.set_velocity(turn_heading_velocity_momentum__velocity, PERCENT)\n            RightBase.set_velocity(turn_heading_velocity_momentum__velocity, PERCENT)\n            LeftBase.spin(REVERSE)\n            RightBase.spin(REVERSE)\n            wait(20, MSEC)\n    else:\n        # right\n        while turn_heading_velocity_momentum__heading + turn_heading_velocity_momentum__momentum < gyro_5.rotation():\n            LeftBase.set_velocity(turn_heading_velocity_momentum__velocity, PERCENT)\n            RightBase.set_velocity(turn_heading_velocity_momentum__velocity, PERCENT)\n            LeftBase.spin(REVERSE)\n            RightBase.spin(REVERSE)\n            wait(20, MSEC)\n    LeftBase.stop()\n    RightBase.stop()\n\n\n\n# Setting state of variables\n\nstate_slapshot = False\npurple_state = False\ndrive_on = True\n\n#helper functions for autonomous\ndef WaitTime(timeinseconds): \n    #wait time very precise\n    wait(timeinseconds, SECONDS)\n\n#def driveever():\n#    LeftBase.spin(REVERSE)\n#    while LeftBase.is_spinning():\n#        RightBase.spin(FORWARD)\ndef driveMM(DrivingMM):\n    #drives but not as precise\n    LeftBase.spin_for(FORWARD,DrivingMM,DEGREES,wait=False)\n    RightBase.spin_for(FORWARD,DrivingMM,DEGREES)\ndef rightTurn(Angle1):\n    #for turning\n    brain_inertial.set_heading(0, DEGREES)\n    RightBase.set_velocity(25, PERCENT)\n    LeftBase.set_velocity(25, PERCENT)\n    global TurnAngle\n    TurnAngle = brain_inertial.rotation()\n    RightBase.spin_for(REVERSE, Angle1, DEGREES, wait=False)\n    LeftBase.spin_for(FORWARD, Angle1, DEGREES)\ndef leftTurn(Angle):\n    #for turning\n    brain_inertial.set_heading(0, DEGREES)\n    RightBase.set_velocity(25, PERCENT)\n    LeftBase.set_velocity(25, PERCENT)\n    global TurnAngle\n    TurnAngle = brain_inertial.rotation()\n    RightBase.spin_for(FORWARD, Angle, DEGREES, wait=False)\n    LeftBase.spin_for(REVERSE, Angle, DEGREES)\ndef leftTurn2(): \n    LeftBase.spin(REVERSE)\n    RightBase.spin(FORWARD)\n\n    '''\n    #while abs(TurnAngle) < Angle: \n        TurnAngle = brain_inertial.rotation()\n        brain.screen.print(TurnAngle)\n        brain.screen.next_row()\n        RightBase.spin(FORWARD)\n        LeftBase.spin(REVERSE)\n    #RightBase.stop()\n    #LeftBase.stop()'''\ndef Shooting():\n    #shoots disks\n    Purpletower.spin(REVERSE)\n    Slapshot.spin(FORWARD)\n    bucket.spin_for(FORWARD,150,DEGREES,wait=False)\n    wait(1,SECONDS)\n    bucket.stop()\n    #driveMM(100)\n    wait(1,MSEC)\n    #driveMM(-100)\n    WaitTime(1)\n    bucket.spin_for(REVERSE,70,DEGREES,wait=False)\n    wait(1,SECONDS)\n'''def Shooting():\n    #shoots disks\n    Purpletower.spin(REVERSE)\n    Slapshot.spin(FORWARD)\n    bucket.spin_for(FORWARD,170,DEGREES,wait=False)\n    wait(1,SECONDS)\n    bucket.stop()\n    driveMM(100)\n    wait(1,MSEC)\n    driveMM(-100)\n    WaitTime(1)\n    bucket.spin_for(REVERSE,170,DEGREES,wait=False)\n    wait(1,SECONDS)'''\ndef StopShoot(): \n    #stops shooting\n    Purpletower.stop()\n    Slapshot.stop()\ndef blueActivate():\n    Bluetower.spin(FORWARD)\n    bluey = True\n    while bluey == True:\n        wait(0.1,MSEC)\n    else:\n        Bluetower.stop()\n        bluey = False\n    Bluetower.stop()\n\ndef activate_arm():\n    #activates bluetower\n    Bluetower.spin(FORWARD)\n    wait(1,SECONDS)\n    Bluetower.stop()\ndef activate_slap():\n    #activates the slapshot\n    Slapshot.spin(FORWARD)\ndef deactivate_slap():\n    #deactivats the slashot \n    Slapshot.stop()\ndef activate_purple():\n    #purple start\n    Purpletower.spin(REVERSE)\ndef deactivate_purple():\n    #purple stop\n    Purpletower.stop()\n\ndef ArmExtention(): \n    #arm extention to get 4 point zone! :)\n    Bluetower.spin_for(FORWARD, 480, DEGREES)\n    WaitTime(0)\n    Bluetower.spin_to_position(0, DEGREES)\n#def DiscDrop(): \n#    Bluetower.spin_for(FORWARD, 675, DEGREES)\n#    WaitTime(0)\n#    Bluetower.spin_to_position(0, DEGREES)\ndef Drivebase_Reverse(DISTANCEINMM): \n    LeftBase.spin_for(REVERSE, DISTANCEINMM, DEGREES,wait=False)\n    RightBase.spin_for(REVERSE, DISTANCEINMM, DEGREES)\ndef BlueTrigger(): \n    Bluetower.spin(FORWARD)\n    WaitTime(2.5)\n    Bluetower.spin_to_position(0, DEGREES)\ndef Bluetower_1():\n    bucket.spin(FORWARD)\n    wait(2,SECONDS)\n    bucket.stop()\n    BlueTrigger()\n    #blue has been triggered yay :)\ndef Drivebase_Reverse3(): \n    LeftBase.spin(REVERSE)\n    RightBase.spin(REVERSE)\n\ndef Drivebase_Forward3(): \n    LeftBase.spin(FORWARD)\n    RightBase.spin(FORWARD)\ndef Purple_1():\n    #purple start and go forward to activate\n    Purpletower.spin(REVERSE) and Drivebase_Forward3\n    wait(9,SECONDS)\n    driveMM(-100)\n    Purpletower.stop()\n#autonomous control programs\n#def distance_driver(distanceInMM):\n#    while distances.object_distance(MM) > distanceInMM:\n#        LeftBase.spin(FORWARD)\n#        RightBase.spin(FORWARD)\n#    LeftBase.stop()\n#    RightBase.stop()\ndef yellow_get_ready():\n    #put the bucket for yellow down\n    bucket.spin(REVERSE)\n    wait(1,SECONDS)\n    bucket.stop()\ndef yellow_activate():\n    #yellow already in position\n    bucket.spin(FORWARD)\n    wait(2, SECONDS)\n    bucket.stop()\n    LeftBase.set_velocity(50, PERCENT)\n    RightBase.set_velocity(50, PERCENT)\n    #driveMM(55)\n    Drivebase_Forward2(0.75)\n    #driveStraight_dividedistanceby2(25,0,60,2)\n    #driveReverse_dividedistanceby2(25,0,60,2)\n    bucket.spin(REVERSE)\n    Drivebase_Reverse2(2)\n    wait(1,SECONDS)\n    bucket.stop()\n\ndef Drivebase_Reverse2(Time): \n    LeftBase.spin(REVERSE)\n    RightBase.spin(REVERSE)\n    WaitTime(Time)\n\ndef Drivebase_Forward2(Time): \n    LeftBase.spin(FORWARD)\n    RightBase.spin(FORWARD)\n    WaitTime(Time)\ndef yellow_shoot():\n    Drivebase_Reverse2(3)\n    yellow_activate()\n    RightBase.set_velocity(100,PERCENT)\n    driveMM(200)\n    leftTurn(231)\n    driveMM(450)\n    leftTurn(90)\n    Drivebase_Forward2(1.4)\n    Shooting()\n    Shooting()\n    Shooting()\ndef actual_autostart():\n    driveStraight_dividedistanceby2(-150,0,60,2)\n    yellow_activate()\n    driveStraight_dividedistanceby2(100,0,60,2)\n    leftTurn(150)\n    driveStraight_dividedistanceby2(250,210,60,2)\n    leftTurn(30)\n    driveStraight_dividedistanceby2(-100,-180,60,2)\n    BlueTrigger()\n    driveStraight_dividedistanceby2(150,-180,60,2)\ndef Part2(): \n    RightBase.set_velocity(100, PERCENT)\n    LeftBase.set_velocity(100, PERCENT)\n    driveMM(250)\n    rightTurn(90)\n    RightBase.set_velocity(100, PERCENT)\n    LeftBase.set_velocity(100, PERCENT)\n    driveMM(585)\n    rightTurn(80)\n    RightBase.set_velocity(100, PERCENT)\n    LeftBase.set_velocity(100, PERCENT)\n    Drivebase_Forward2(1.7)\n    leftTurn2()\n    WaitTime(0.45)\n    LeftBase.stop()\n    RightBase.stop()\n    Drivebase_Forward2(1)\n    WaitTime(0.35)\n    LeftBase.stop()\n    RightBase.stop()\n    Purple_1() \n    leftTurn(90)\n    Drivebase_Reverse2(0.5)\n    LeftBase.stop()\n    RightBase.stop()\n\n\n\ndef touchled_control():\n    touchlednum = 0\n    while True:\n        brain_inertial.set_heading(0,DEGREES)\n        if touchled_4.pressing() or controller.buttonL3.pressing():\n            touchlednum = touchlednum + 1\n            wait(0.25,SECONDS)\n            if touchlednum == 1:\n                touchled_4.set_color(Color.RED)\n                #yellow_shoot()\n                #Part2()\n                blueActivate()\n            elif touchlednum == 2:\n                touchled_4.set_color(Color.GREEN)\n                #Part2()\n            elif touchlednum == 3:\n                touchlednum = 0\n                touchled_4.set_color(Color.BLUE)\n        else:\n            pass\nset_robot_motors()\nbrain.screen.print(\"Motors have been set.\")\nbrain.screen.next_row()\nbrain_inertial.calibrate()\nbrain.screen.print(\"Brain_inertial has been calibrated. \")\ntouchled_control()","textLanguage":"python","rconfig":[{"port":[2],"name":"LeftBase","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[10],"name":"RightBase","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[1],"name":"Slapshot","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[3],"name":"Bluetower","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[12],"name":"Purpletower","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[7],"name":"bucket","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[5],"name":"gyro_5","customName":false,"deviceType":"Gyro","deviceClass":"gyro","setting":{},"triportSourcePort":22},{"port":[],"name":"controller","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","e":"","eDir":"false","f":"","fDir":"false","l3r3":"","l3r3Dir":"false","drive":"none"},"triportSourcePort":22},{"port":[4],"name":"touchled_4","customName":false,"deviceType":"TouchLED","deviceClass":"touchled","setting":{},"triportSourcePort":22},{"port":[6],"name":"bumper_6","customName":false,"deviceType":"Bumper","deviceClass":"bumper","setting":{}}],"slot":5,"platform":"IQ","sdkVersion":"20220726.10.00.00","appVersion":"2.4.5","minVersion":"2.4.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"Second","target":"Physical"}